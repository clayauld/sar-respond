# **Automated Geospatial Intelligence for Search and Rescue: A Comprehensive Architectural Analysis of CalTopo Team API Integration**

## **1. Introduction: The Operational Imperative for Programmatic GIS**

The modern Search and Rescue (SAR) operational environment is increasingly defined not by the scarcity of information, but by the velocity at which data must be processed and visualized. In the initial "hasty" phase of a mission, the Incident Commander (IC) and planning section are often overwhelmed with logistical tasks: verifying subject details, calling out resources, establishing the Incident Command Post (ICP), and defining search areas. Historically, the creation of the Common Operating Picture (COP)—the geospatial source of truth for the mission—has been a manual, secondary task performed ad-hoc. This manual latency creates a critical gap: the "Golden Hour" of response often passes before a unified map is available to field teams.  
The integration of custom incident management software, such as the sar-respond application, with high-fidelity mapping platforms like CalTopo represents a paradigm shift from reactive to proactive GIS (Geographic Information Systems) management. By automating the generation of mission maps via the CalTopo Team API, agencies can ensure that a standardized, operationally ready map exists the moment a callout is initiated. This capability allows for the immediate visualization of theoretical search areas, the automated plotting of the subject’s Last Known Point (LKP), and the instant distribution of digital maps to responders' mobile devices before they even leave their homes.  
This report provides an exhaustive technical analysis of the CalTopo Team API, specifically tailored to the use case of programmatically creating maps from templates or GeoJSON backups. It explores the architectural constraints of the platform, the specific endpoints required for map generation, and the complex logic needed to replicate the "Mutual Aid Incident" structure programmatically. Furthermore, it addresses the integration strategies for the sar-respond application, detailing the Python-based logic required to handle authentication, payload construction, and error resilience in a life-safety critical system.

## **2. CalTopo Team API Architecture and Security Model**

To successfully architect an automated mapping solution, one must first understand the underlying philosophy of the CalTopo Team API. Unlike consumer mapping APIs (such as Google Maps or Mapbox), which primarily serve tiles or route data to a client, the CalTopo API is designed to manipulate stateful "Collaborative Maps." These are persistent data containers that synchronize geospatial features across multiple clients in real-time.

### **2.1 The Service Account Paradigm**

Access to the Team API is governed by a strict service-oriented architecture. Individual user credentials (username/password) are not used for API access. Instead, the system utilizes **Service Accounts**—specialized identities created by Team Admins that possess specific permissions within the team structure.  
The Service Account model offers several operational advantages for a system like sar-respond. First, it decouples the application's access from any single human user. If the team's GIS Specialist leaves the organization, the application's access remains uninterrupted. Second, it allows for granular permission scoping. A Service Account can be granted **UPDATE** or **ADMIN** privileges, allowing it to create and modify maps without necessarily having the ability to alter billing or team membership settings.

### **2.2 HMAC-SHA256 Authentication and Request Signing**

Security in the CalTopo API is enforced through a Hash-Based Message Authentication Code (HMAC) using the SHA-256 algorithm. This is a robust, stateless authentication method that ensures message integrity and authenticity without transmitting the secret key over the network.  
The authentication process requires the sar-respond application to manage two critical pieces of information: the **Credential ID** and the **Credential Secret**. The Credential ID is a public identifier included in the request headers, while the Credential Secret is a private key known only to the application and the CalTopo server. The secret is displayed only once upon the creation of the Service Account and must be stored securely in the application's encrypted environment variables or secrets manager.  
For every API request, the application must construct a digital signature. This signature is generated by concatenating the HTTP method (e.g., POST), the full request URL, a timestamp (in epoch milliseconds), and the JSON payload string (if present). This concatenated string is then hashed using the Credential Secret. The resulting hash is sent in the X-CalTopo-Signature header.  
This mechanism has profound implications for the sar-respond implementation. The application cannot simply use a client-side JavaScript library to call the API, as doing so would expose the Credential Secret to the user's browser. Instead, all map creation logic must be handled server-side (likely within the Django/Python backend of sar-respond), acting as a proxy between the user's "Create Mission" action and the CalTopo servers. The server must also handle timestamp generation accurately; CalTopo enforces a validity window for timestamps to prevent replay attacks, meaning the application's server clock must be synchronized via NTP (Network Time Protocol) to ensure requests are not rejected.  
\#\#\# 2.3 The RESTful Nature of the API  
The CalTopo API follows RESTful principles, utilizing standard HTTP verbs to perform actions on resources.

- **GET:** Used to retrieve the current state of a map or account data.
- **POST:** Used to create new resources (maps, objects) or update existing ones.
- **DELETE:** Used to remove objects or maps.

Understanding this resource hierarchy is critical. The API exposes Team (or Account) resources and Map resources. The creation of a map is an action performed on a Team Account, while the addition of a marker is an action performed on a Map. This distinction dictates the endpoint structure: creating a map requires targeting https://caltopo.com/api/v1/acct/{team\_id}/CollaborativeMap, whereas adding a search sector requires targeting https://caltopo.com/api/v1/map/{map\_id}/Polygon.  
\#\# 3. Programmatic Map Creation: The CollaborativeMap Endpoint  
The core requirement of the user's request is to create a new map via the API. The CollaborativeMap endpoint is the gateway for this functionality. This endpoint instantiates a new map container within the specified Team Account. It is important to note that maps created via this endpoint are immediately "owned" by the team, inheriting the data retention and ownership policies of the organization, rather than being tied to a personal account.

### **3.1 The Request Payload Structure**

The POST request to create a map is not merely a signal to open a blank file; it is a data injection event. The payload allows the application to define the map's metadata and its initial geospatial state in a single transaction. This efficiency is vital for the "Template" use case, as it prevents the need for dozens of subsequent API calls to populate the map.  
The payload consists of a JSON object with two primary children: properties and state.

#### **3.1.1 The Properties Object**

The properties object defines the administrative metadata of the map.

- **Title:** This field is mandatory and should be programmatically generated by sar-respond. A recommended pattern is to combine the mission number and subject name, e.g., "2024-001: Missing Hiker \- Smith". This ensures that the map list remains sortable and searchable within the CalTopo interface.
- **Mode:** The mode property dictates the user interface and available tools. For sar-respond, this must be set to "sar". The SAR mode unlocks specialized tools critical for response, such as the "Find Locators" tool, assignment buffering, and probability density usage. Setting this to "cal" (Recreational) would deprive the Incident Management Team (IMT) of these essential features.
- **Map Configuration (mapConfig):** This is a nested JSON string (serialized JSON) that defines the visual appearance of the map. It controls the stack of base layers (e.g., MapBuilder Topo, NAIP Imagery, Scanned USGS Topos) and overlays (e.g., Slope Angle Shading). By copying this configuration string from a template map, the application ensures that every new mission map opens with the team's preferred cartography—for example, high-contrast topographic lines for navigation and shaded relief for terrain analysis.
- **Sharing:** This property controls the default visibility. The API supports values like "PRIVATE", "SECRET", "URL", and "PUBLIC". For active SAR operations, "SECRET" is the operational standard. This setting hides the map from public search indexes but allows access to anyone possessing the specific, obfuscated URL. This balance allows sar-respond to distribute the link to volunteers without requiring every volunteer to have a pre-provisioned CalTopo account, while maintaining operational security.

#### **3.1.2 The State Object (GeoJSON)**

The state object is the container for the geospatial content. It follows the GeoJSON standard, specifically a FeatureCollection. This is where the integration of the "Map Template" or "GeoJSON Backup" occurs.  
The state object allows sar-respond to pre-seed the map with critical operational data.

- **Static Infrastructure:** The template can include the locations of standard helicopter landing zones (LZs), repeater sites, and road closures.
- **Operational Boundaries:** The template can include the team's response area boundary or pre-planned search sectors for high-frequency callout locations.
- **Placeholders:** The application can inject placeholder markers for the ICP or LKP, which can be moved by the first responder on scene.

The API parses this GeoJSON and converts it into native CalTopo objects. It is robust enough to handle complex geometries, including multi-polygons (search areas with exclusion zones) and linestrings with thousands of vertices (trails or roads).

### **3.2 Handling Map Object Types**

When constructing the GeoJSON payload, the application must adhere to CalTopo's specific property schema to ensure objects render correctly. Standard GeoJSON only defines geometry; it does not define style. CalTopo uses the properties dictionary within each Feature to store styling data.  
**Table 1: CalTopo-Specific GeoJSON Properties**

| Object Type    | Required Properties | Description                                     |
| :------------- | :------------------ | :---------------------------------------------- |
| **Marker**     | title, description  | Basic metadata for the point.                   |
| **Marker**     | marker-symbol       | The icon code (e.g., "f-star", "wpt").          |
| **Marker**     | marker-color        | Hex code without hash (e.g., "FF0000" for red). |
| **Line**       | stroke              | Stroke color (Hex).                             |
| **Line**       | stroke-width        | Thickness in pixels.                            |
| **Line**       | stroke-opacity      | Transparency (0.0 to 1.0).                      |
| **Polygon**    | fill                | Fill color (Hex).                               |
| **Polygon**    | fill-opacity        | Fill transparency.                              |
| **Assignment** | type: "Assignment"  | Marks the object as a manageble SAR assignment. |

For sar-respond, the Assignment type is particularly valuable. If the template contains pre-drawn search segments, ensuring they are tagged with "type": "Assignment" in the GeoJSON properties allows the Planning Section to immediately begin tracking their status (e.g., "Assigned," "Completed," "In Progress") using CalTopo's built-in operational period management tools.

## **4. The "Template" Workflow: Cloning Maps Programmatically**

The user's requirement to create a map "from a map template" or a "GeoJSON backup" necessitates a specific architectural pattern. The CalTopo API does not currently expose a single atomic endpoint like POST /copy-map?source={id}. Therefore, the "Clone" functionality must be implemented in the logic of the sar-respond application using a "Fetch-Transform-Push" cycle.

### **4.1 Strategy A: The "Live Template" Clone**

In this approach, the team maintains a dedicated map in their CalTopo account labeled "MASTER TEMPLATE \- DO NOT EDIT". This map is kept up-to-date with the latest operational layers and icons by the team's GIS specialist using the standard web interface.  
**Step 1: Fetch.** The application sends a GET request to https://caltopo.com/api/v1/map/{template\_map\_id}/since/0. The since/0 parameter is crucial; it instructs the API to retrieve the entire delta of the map from timestamp zero, effectively downloading the full current state.  
**Step 2: Transform.** The application receives the JSON response. It extracts the state object (the FeatureCollection). The application logic must then perform a sanitization pass. This involves stripping out any unique identifiers (id or folderId) that tie the objects to the original map, ensuring they are treated as new objects in the destination map. This prevents "ghost links" where modifying an object on the new map might inadvertently attempt to update the template (though the API structure largely prevents this, client-side caching can sometimes be confused by duplicate IDs).  
**Step 3: Push.** The sanitized state object is then injected into the payload of the CollaborativeMap creation request (as described in Section 3.1). The new map is created with an exact duplicate of the template's geometry and styling.  
This strategy is highly flexible because it allows non-technical users to update the template simply by editing the "MASTER TEMPLATE" map in CalTopo. No code changes are required in sar-respond to add a new repeater location to the standard loadout.

### **4.2 Strategy B: The "GeoJSON Backup" (Cold Storage)**

The user also suggested using a "GeoJSON backup." This approach involves exporting the template map to a static .json file and storing it within the sar-respond application's storage (either as a file on disk or a JSONBlob in the database).  
**Step 1: Load.** When a mission is created, the application reads the stored JSON string from its internal database.  
**Step 2: Injection.** The application parses the JSON to allow for dynamic variable substitution. For example, if the GeoJSON contains a placeholder marker titled "{{LKP}}", the application can programmatically replace the coordinates of this feature with the coordinates entered in the "New Mission" form of sar-respond.  
**Step 3: Push.** The modified GeoJSON is sent to the CollaborativeMap endpoint.  
This strategy offers superior reliability. It removes the dependency on the initial GET request to CalTopo. If CalTopo's read servers are experiencing latency, or if a user accidentally deletes the "MASTER TEMPLATE" map, the application can still generate new mission maps from its internal backup. For a mission-critical application like sar-respond, this reliability often outweighs the flexibility of the Live Template.

## **5. Mutual Aid Incidents and Team Structure Management**

A significant portion of the user's request focuses on "creating Mutual Aid Incidents using the API." This presents the most complex challenge in the integration, as the CalTopo API's capabilities in this specific area diverge from its web interface capabilities.

### **5.1 The Hierarchy of CalTopo Team Data**

To understand the challenge, we must rigorously define the data containers involved:

1. **Parent Team Account:** The root organizational unit (e.g., "County SAR").
2. **Sub-Teams:** Permanent subdivisions (e.g., "K9 Team"). These have their own team_id and map lists but share the parent's billing.
3. **Mutual Aid Incidents (formerly Events):** These are temporary, time-bounded containers designed for multi-agency incidents. They function like sub-teams but have an **expiration date** and are specifically designed to allow "guest" access via a join code.

### **5.2 The API Gap: Creation of Mutual Aid Incidents**

Extensive analysis of the CalTopo API documentation and community reverse-engineering efforts indicates that **there is currently no documented public endpoint for programmatically creating a Mutual Aid Incident**. The POST endpoints are generally restricted to creating _content_ (maps, layers, objects) rather than _structural containers_ (sub-teams, incidents). The creation of a Mutual Aid Incident via the web UI likely triggers internal administrative calls that are not exposed to the standard Team API credentials.  
This limitation means that sar-respond cannot, at this time, execute a command like create_incident(name="Search 24-01", expires="2024-02-01") and receive a new container ID in response. This requires the development of architectural workarounds to satisfy the user's operational requirement of isolating mission data.

### **5.3 Architectural Pattern 1: The "Active Missions" Permanent Sub-Team**

The most robust workaround is to abandon the concept of creating a _new team container_ for every mission and instead utilize a single **Permanent Sub-Team** dedicated to active operations.  
**Implementation:**

1. The Team Admin manually creates a Sub-Team named "Active Missions" or "Dispatch" via the web UI. This is done once.
2. The team_id of this Sub-Team is hardcoded into the sar-respond configuration settings.
3. When a new mission is triggered, the API creates the map inside this specific team_id.

**Operational Impact:** All active mission maps live in one folder. This provides a "Dashboard" view for the GIS team. To manage access, the application relies on the **Map-Level Security** (Secret URLs) rather than **Team-Level Security**. Since the generated maps are set to sharing: "SECRET", a user from another agency who is given the URL for "Mission A" cannot see "Mission B" even though they are in the same Sub-Team container, provided they are not added as a member of the Sub-Team itself.

### **5.4 Architectural Pattern 2: The "Pre-Provisioned Pool"**

If the operational requirement strictly demands the use of "Mutual Aid Incident" containers (perhaps to use the specific "Guest Join Code" feature which allows non-account holders to join the team temporarily), a pooling strategy can be employed.  
**Implementation:**

1. The Admin manually creates 10 generic Mutual Aid Incidents (e.g., "Incident Alpha," "Incident Bravo,"... "Incident Zulu") and sets their expiration dates far in the future.
2. The sar-respond database stores the team_id and admin_url for each of these incidents.
3. The application tracks the "State" of each incident (Available vs. In-Use).
4. When a callout occurs, the app "checks out" the next available incident (e.g., "Incident Alpha").
5. The app uses the API to rename the "Incident Alpha" _map_ (though renaming the Team itself via API is not supported) or simply places the new named map inside it.
6. Responders are directed to join "Incident Alpha."

**Critique:** This method introduces significant state management complexity. The application must handle logic for "checking in" incidents (clearing old maps) and handling the exhaustion of the pool. While it mimics the "new incident" behavior, the overhead is high compared to Pattern 1.

### **5.5 Recommendation**

For the sar-respond application, **Pattern 1 (Permanent Sub-Team)** is the recommended approach. It aligns with the API's strengths (reliable map creation) and avoids the fragility of managing a pool of containers or relying on undocumented endpoints. The application can emulate the "Incident" feel by generating a dedicated Mission Dashboard page in its own UI that displays the Map URL, the radio frequencies, and the subject info, effectively serving as the container for the user.

## **6. Integration Engineering: Implementing the Solution**

The integration of CalTopo into sar-respond requires specific engineering practices to ensure reliability. Assuming sar-respond is built on a Python web framework (Django or Flask), the following technical implementation details are critical.

### **6.1 Dependency Management**

While there are third-party wrappers like caltopo_python (formerly sartopo_python), relying on them for a production life-safety application introduces third-party risk. The API surface area required for this integration is relatively small (Signing, GET Map, POST Map). Therefore, it is recommended to implement a custom API client within the application's codebase using the standard requests library. This ensures the team maintains full control over the authentication logic and dependency chain.

### **6.2 The Python Map Creation Service**

The core logic should be encapsulated in a CalTopoService class. Below is the architectural blueprint for the map creation method, incorporating the "Template Clone" logic.

```python
import time
import json
import hmac
import hashlib
import requests
from django.conf import settings

class CalTopoService:
    def __init__(self):
        self.base_url = "https://caltopo.com/api/v1"
        self.cred_id = settings.CALTOPO_CRED_ID
        self.cred_secret = settings.CALTOPO_CRED_SECRET
        self.target_team_id = settings.CALTOPO_TARGET_TEAM_ID  # ID of "Active Missions" Sub-Team
        self.template_map_id = settings.CALTOPO_TEMPLATE_MAP_ID

    def _sign_request(self, method, path, payload_str=""):
        """
        Generates the HMAC-SHA256 signature required for authentication.
        """
        timestamp = int(time.time() * 1000)
        msg = f"{method} {path} {timestamp}{payload_str}"

        signature = hmac.new(
            self.cred_secret.encode('utf-8'),
            msg.encode('utf-8'),
            hashlib.sha256
        ).hexdigest()

        return {
            "Content-Type": "application/json",
            "X-CalTopo-Key": self.cred_id,
            "X-CalTopo-Timestamp": str(timestamp),
            "X-CalTopo-Signature": signature
        }

    def get_template_geojson(self):
        """
        Fetches the state of the template map.
        """
        path = f"/map/{self.template_map_id}/since/0"
        headers = self._sign_request("GET", path)
        response = requests.get(f"{self.base_url}{path}", headers=headers, timeout=10)
        response.raise_for_status()
        return response.json()['state']

    def create_mission_map(self, mission_instance):
        """
        Orchestrates the creation of a new mission map.
        """
        # Step 1: Fetch Template Data
        try:
            geo_state = self.get_template_geojson()
        except requests.RequestException:
            # Fallback to local backup if API fetch fails
            geo_state = self._load_local_backup_geojson()

        # Step 2: Inject Dynamic Data (e.g., LKP Marker)
        if mission_instance.lkp_coords:
            lkp_feature = self._create_lkp_feature(mission_instance.lkp_coords)
            geo_state['features'].append(lkp_feature)

        # Step 3: Construct Payload
        payload = {
            "properties": {
                "title": f"Mission {mission_instance.case_number}: {mission_instance.subject_name}",
                "mode": "sar",
                "sharing": "SECRET",
                "mapConfig": json.dumps({"activeLayers": [["mbt", 1]]}) # Enforce standard layers
            },
            "state": geo_state
        }
        payload_str = json.dumps(payload)

        # Step 4: Execute Creation
        path = f"/acct/{self.target_team_id}/CollaborativeMap"
        headers = self._sign_request("POST", path, payload_str)

        response = requests.post(f"{self.base_url}{path}", data=payload_str, headers=headers, timeout=15)
        response.raise_for_status()

        # Step 5: Extract and Return Map ID
        result = response.json()
        return result['result']['id']
```

### **6.3 Database Integration and State Management**

The sar-respond database schema must be updated to store the relationship between the internal Mission record and the external CalTopo map.  
**Table 2: Recommended Database Schema Extensions**

| Field Name        | Type          | Purpose                                                     |
| :---------------- | :------------ | :---------------------------------------------------------- |
| caltopo_map_id    | CharField(16) | Stores the unique ID returned by the API (e.g., "715K").    |
| caltopo_url       | URLField      | Stores the direct viewer link (https://caltopo.com/m/715K). |
| caltopo_admin_url | URLField      | Stores the admin link if separate.                          |
| map_created_at    | DateTime      | Timestamp of creation for audit logs.                       |
| is_synced         | Boolean       | Flag to track if the map has been successfully initialized. |

When a map is successfully created, the caltopo_url should be exposed prominently in the application's UI. This allows the Incident Commander to click one button to open the map on a large display in the command post.

### **6.4 Asynchronous Task Processing**

Map creation involves network I/O, which introduces latency. If the CalTopo API is slow or the payload is large (complex template), a synchronous request might time out the user's browser during the "Create Mission" form submission.  
It is highly recommended to offload the map creation to an asynchronous task queue using **Celery** or **Django Q**.

1. **User Action:** User clicks "Create Mission."
2. **App Response:** App saves the mission to the database and immediately returns the Mission View page with a "Map: Provisioning..." status indicator.
3. **Worker Process:** The background worker executes create_mission_map().
4. **Completion:** Upon success, the worker updates the caltopo_url field in the database and pushes a WebSocket update (or simply waits for page refresh) to change the status to "Map: Ready" with a clickable link.

This architecture ensures the sar-respond application remains snappy and responsive even if external API calls take several seconds.

## **7. Advanced Capabilities: Beyond Basic Map Creation**

Once the foundational pipeline of creating maps from templates is established, sar-respond can leverage the API for deeper operational integration.

### **7.1 Automated Folder Organization**

The user's interest in "Teams folders" touches on organizational hierarchy. While the API creates the map in a team _account_, organizing the map's _contents_ into folders is done via the GeoJSON payload.

- **Use Case:** Automatically creating empty folders for "Tracks \- Period 1", "Tracks \- Period 2", and "Clues."
- **Implementation:** The GeoJSON standard does not natively support folders. CalTopo extends this by using a specific property schema. To create a folder structure, the application must include Folder objects in the payload or rely on the folderId property of features.
- **Logic:** The application can iterate through the template features. If the template has a folder named "Clues" with ID uuid-1, the application can preserve this. If the application wants to create a _new_ folder for the specific date, it generates a new UUID, creates a Folder object, and assigns it to the payload.

### **7.2 Live Integration of Callout Data**

The sar-respond application likely contains data about which responders are attending. This data can be pushed to the map.

- **Responder Markers:** When a member responds "Attending" in the app, the application can fire a POST /api/v1/map/{map_id}/Marker request to plot a marker at the ICP labeled with their name/callsign. This gives the IC an instant visual representation of available manpower at the staging area.

### **7.3 Integration with Position Reporting (Live Tracking)**

The CalTopo API supports a specialized endpoint for live position reporting: POST /api/v1/position/report/{account_id}. This is distinct from the map object API.

- **Potential:** If sar-respond has a mobile component or processes APRS/Meshtastic feeds, it can act as a gateway, forwarding these coordinates to the CalTopo map.
- **Configuration:** The application can automatically configure the map to display these live tracks by ensuring the "Locator" overlay is enabled in the mapConfig property during creation.

## **8. Conclusion and Strategic Recommendations**

The integration of sar-respond with the CalTopo Team API represents a significant maturation of SAR technology capabilities. By moving from manual map creation to automated, template-driven instantiation, the agency eliminates a critical bottleneck in the initial response phase.  
**Summary of Findings:**

1. **Map Creation:** The POST /api/v1/acct/{id}/CollaborativeMap endpoint is the robust, production-ready mechanism for this task. It supports full customization of the map's initial state via GeoJSON.
2. **Template Strategy:** The "Clone" pattern (fetching a master map's state and injecting it into a new map) is the most flexible approach, allowing non-developers to maintain the template using standard CalTopo tools.
3. **Mutual Aid Limitations:** The lack of a public API to create "Mutual Aid Incident" containers forces an architectural pivot. The recommended solution is to use a **Permanent "Active Missions" Sub-Team** and rely on map-level SECRET URL sharing to secure mission data.
4. **Engineering Rigor:** Success depends on a backend-driven architecture (Python/Django) that securely handles HMAC signing and employs asynchronous workers to manage network latency.

By implementing the architectural patterns detailed in this report, the sar-respond application will transform from a logistical tracking tool into a powerful driver of geospatial intelligence, ensuring that every search begins with the best possible map, available instantly to those who need it most.  
**Table 3: Recommended Configuration Map for sar-respond**

| Configuration Key      | Example Value              | Description                                   |
| :--------------------- | :------------------------- | :-------------------------------------------- |
| CALTOPO_API_URL        | https://caltopo.com/api/v1 | Base endpoint.                                |
| CALTOPO_CRED_ID        | env_var_loaded_id          | Service Account ID.                           |
| CALTOPO_CRED_SECRET    | env_var_loaded_secret      | Service Account Secret (HMAC Key).            |
| CALTOPO_TEAM_ID        | 12345                      | Target Sub-Team ID (e.g., "Active Missions"). |
| CALTOPO_TEMPLATE_ID    | ABCDE                      | Map ID of the "Master Template".              |
| CALTOPO_MAP_MODE       | sar                        | Enforces SAR-specific tools.                  |
| CALTOPO_DEFAULT_LAYERS | json_string                | Backup configuration if template fetch fails. |

#### **Works cited**

1. Supported API for Teams | CalTopo Training, https://training.caltopo.com/all\_users/team-accounts/teamapi
2. Team Accounts | CalTopo Training, https://training.caltopo.com/all\_users/team-accounts
3. Import and Export Functions \- CalTopo Training, https://training.caltopo.com/all\_users/import-export
4. What is the required GeoJSON data to import into Caltopo? \- GIS Stack Exchange, https://gis.stackexchange.com/questions/495645/what-is-the-required-geojson-data-to-import-into-caltopo
5. Creating SAR Objects \- CalTopo Training, https://training.caltopo.com/firstresponse/basics/sarobj
6. Using Segments and Assignments | CalTopo Training, https://training.caltopo.com/firstresponse/course/seg2
7. Mutual Aid Incidents (Formerly Events) \- CalTopo Training, https://training.caltopo.com/all\_users/team-accounts/tempteam
8. ncssar/sartopo_python: Python calls for the caltopo / sartopo API \-- SUPERCEDED by caltopo_python \- GitHub, https://github.com/ncssar/sartopo\_python
9. caltopo-python \- PyPI, https://pypi.org/project/caltopo-python/2.0.0/
10. Folders, Bulk Ops, and Data Management in CalTopo | CalTopo ..., https://training.caltopo.com/all\_users/objects/folders
11. Live Team Tracking \- CalTopo Training, https://training.caltopo.com/all\_users/team-accounts/team-tracking
12. search-and-rescue · GitHub Topics, https://github.com/topics/search-and-rescue?o=desc\&s=updated
